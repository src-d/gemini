package tech.sourced.gemini

import java.io.File
import java.nio.file.Files

import gopkg.in.bblfsh.sdk.v1.protocol.generated.ProtocolServiceGrpc.ProtocolService
import gopkg.in.bblfsh.sdk.v1.protocol.generated._
import gopkg.in.bblfsh.sdk.v1.uast.generated.{Node, Role}
import io.grpc.{ManagedChannelBuilder, ServerBuilder}
import org.apache.spark.internal.Logging
import org.bblfsh.client.BblfshClient
import org.scalatest.{BeforeAndAfterAll, FlatSpec, Matchers}
import tech.sourced.featurext.generated.service.FeatureExtractorGrpc.FeatureExtractor
import tech.sourced.featurext.generated.service._
import tech.sourced.gemini.util.Logger

import scala.concurrent.{ExecutionContext, Future}
import scala.util.parsing.json.JSON

@tags.DB
class FileQuerySpec extends FlatSpec
  with Matchers
  with BaseDBSpec
  with Logging
  with BeforeAndAfterAll {

  val logger = Logger("gemini")

  keyspace = "fileQuerySpec"

  val duplicateFile = RepoFile(
    "github.com/src-d/borges.git",
    "commit-id",
    "consumer.go",
    "9f653118e787febce824759bb5c4ef17fe4da7b0")
  val similarFile = RepoFile(
    "github.com/erizocosmico/borges.git",
    "commit-id",
    "consumer.go",
    "e32d54ae4b969ac13f737efaf1c11ccfc52bbe5b")
  var licenceFile = RepoFile(
    "null/Users/alex/src-d/gemini",
    "4aa29ac236c55ebbfbef149fef7054d25832717f",
    "LICENSE",
    "097f4a292c384e002c5b5ce8e15d746849af7b37"
  )
  var funcFile = RepoFile(
    "null/Users/smacker/tmp/func-level-repo/.git",
    "27f7db976994baf808b205c1ca95ba961cebf59d",
    "funcs.go",
    "cf4cf63cf8da4243dd04bd7e1c09ecfda2567d7e"
  )

  override def beforeAll(): Unit = {
    super.beforeAll()

    insertHashtables(readHashItemsFromFile("src/test/resources/hashtables.json"))
    insertHashtables(readHashItemsFromFile("src/test/resources/hashtables_func.json"))
    insertMeta(Array(duplicateFile, similarFile, licenceFile, funcFile))
  }

  "Read from Database" should "return same results as written" in {
    val gemini = Gemini(null, logger, keyspace)
    val bblfshClient = BblfshClient(Gemini.defaultBblfshHost, Gemini.defaultBblfshPort)
    val channel = ManagedChannelBuilder
      .forAddress(Gemini.defaultFeHost, Gemini.defaultFePort)
      .usePlaintext(true)
      .build()
    val feClient = FeatureExtractorGrpc.stub(channel)

    val QueryResult(duplicates, _) = gemini.query(
      "src/test/resources/LICENSE",
      cassandra,
      bblfshClient,
      Gemini.fileSimilarityMode,
      "",
      feClient)

    duplicates should not be empty
    duplicates.head.sha should be("097f4a292c384e002c5b5ce8e15d746849af7b37") // git hash-object -w LICENSE
    duplicates.head.repo should be("null/Users/alex/src-d/gemini")
    duplicates.head.commit should be("4aa29ac236c55ebbfbef149fef7054d25832717f")
    channel.shutdownNow()
    //TODO(bzz): bblfshClient.shutdownNow() after https://github.com/bblfsh/client-scala/issues/71
  }

  /**
    * Unit test without any dependencies beside cassandra
    * - it loads .json fixtures to hashtables table for 2 hashed files:
    *     one of which is src/test/resources/consumer.go
    *     one is similar to src/test/resources/consumer.go
    * - it fills meta table with those 2 files
    * - it uses mocks for FE and Bblfsh
    * - feature extractor mock always return features, extracted for this file
    * - docfreq.json generated by hash with default params for siva files in src/test/resources/duplicate-files
    *
    * DB fixture created manually by getting values from DB filled by hash
    * to generate new fixture for features extractors - just dump response of service to json
    * there is no fixture for bblfsh because we do nothing with UAST beside passing it to feature extractor
    */
  var queryResult : QueryResult = _
  "Query for similar files" should "return results" in {
    insertDocFreq(OrderedDocFreq.fromJson(new File("src/test/resources/docfreq.json")))

    val features = readFeaturesFromFile("src/test/resources/features.json")

    val server = ServerBuilder
      .forPort(0)
      .addService(ProtocolServiceGrpc.bindService(bblfshMock(new Node), ExecutionContext.global))
      .addService(FeatureExtractorGrpc.bindService(feMock(features), ExecutionContext.global))
      .build
      .start()

    val channel = ManagedChannelBuilder.forAddress("localhost", server.getPort).usePlaintext(true).build()
    val bblfshStub = BblfshClient("localhost", server.getPort)
    val feStub = FeatureExtractorGrpc.stub(channel)

    // full duplicate
    val dupFile = new File("src/test/resources/consumer.go")
    val fileQuery = new FileQuery(
      cassandra,
      bblfshStub,
      feStub,
      "",
      log,
      keyspace,
      Gemini.tables,
      Gemini.fileSimilarityMode)

    queryResult = fileQuery.find(dupFile)

    server.shutdown()
    channel.shutdownNow()
  }

  it should "return duplicates" in {
    val QueryResult(duplicates, _) = queryResult

    duplicates.size shouldEqual 1
    duplicates.last shouldEqual duplicateFile
  }

  it should "return similar files" in {
    val QueryResult(_, similar) = queryResult

    similar.size shouldEqual 1
    similar.last shouldEqual SimilarFile(similarFile)
  }

  "Query for similar funcs" should "return results" in {
    insertDocFreq(OrderedDocFreq.fromJson(new File("src/test/resources/docfreq_func.json")))

    val features = readFeaturesFromFile("src/test/resources/features_func.json")

    val uast = new Node(
      roles = Seq(Role.FUNCTION, Role.DECLARATION),
      children = Seq(new Node(
        roles = Seq(Role.FUNCTION, Role.IDENTIFIER, Role.NAME),
        token = "TestFunc"
      ))
    )
    val server = ServerBuilder
      .forPort(0)
      .addService(ProtocolServiceGrpc.bindService(bblfshMock(uast), ExecutionContext.global))
      .addService(FeatureExtractorGrpc.bindService(feMock(features), ExecutionContext.global))
      .build
      .start()

    val channel = ManagedChannelBuilder.forAddress("localhost", server.getPort).usePlaintext(true).build()
    val bblfshStub = BblfshClient("localhost", server.getPort)
    val feStub = FeatureExtractorGrpc.stub(channel)

    val similarFile = new File("src/test/resources/func_mod.go")
    val fileQuery = new FileQuery(
      cassandra,
      bblfshStub,
      feStub,
      "",
      log,
      keyspace,
      Gemini.tables,
      Gemini.funcSimilarityMode)

    queryResult = fileQuery.find(similarFile)

    channel.shutdownNow()
    server.shutdown()

    val QueryResult(duplicates, similar) = queryResult

    duplicates.size shouldEqual 0
    similar.size shouldEqual 1
  }

  // If we would need this mock somewhere else better to move them in traits

  def readFeaturesFromFile(path: String): Seq[Feature] = {
    val file = new File(path)
    val byteArray = Files.readAllBytes(file.toPath)
    val jsonData = JSON.parseFull(new String(byteArray))

    jsonData match {
      case Some(m: Map[_, _]) => {
        val featuresMap = m.asInstanceOf[Map[String, Double]]
        val iter = featuresMap.map { case(key, value) =>
          Feature(name = key, weight = value.toInt)
        }
        iter.toSeq
      }
      case _ => throw new Exception("incorrect json")
    }
  }

  def bblfshMock(uast: Node): ProtocolService = {
    class BblfshServerMock extends ProtocolService {
      override def parse(request: ParseRequest): Future[ParseResponse] = {
        Future.successful(ParseResponse(uast = Some(uast)))
      }

      override def nativeParse(request: NativeParseRequest): Future[NativeParseResponse] = {
        Future.successful(NativeParseResponse())
      }

      override def version(request: VersionRequest): Future[VersionResponse] = {
        Future.successful(VersionResponse())
      }

      override def supportedLanguages(request: SupportedLanguagesRequest): Future[SupportedLanguagesResponse] = {
        Future.successful(SupportedLanguagesResponse())
      }
    }

    new BblfshServerMock
  }

  def feMock(features: Seq[Feature]): FeatureExtractor = {
    class FEServerMock extends FeatureExtractor {
      override def identifiers(request: IdentifiersRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply(features=features))
      }

      override def literals(request: LiteralsRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply())
      }

      override def uast2Seq(request: Uast2seqRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply())
      }

      override def graphlet(request: GraphletRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply())
      }
    }

    new FEServerMock
  }

  def readHashItemsFromFile(path: String): Iterable[HashtableItem] = {
    val file = new File(path)
    val byteArray = Files.readAllBytes(file.toPath)
    val jsonData = JSON.parseFull(new String(byteArray))

    jsonData match {
      case Some(m: List[_]) => {
        m.map { l =>
          val r = l.asInstanceOf[List[String]]
          HashtableItem(hashtable=r(0).toInt, v=r(1), sha1=r(2))
        }
      }
      case _ => throw new Exception("incorrect json")
    }
  }
}
